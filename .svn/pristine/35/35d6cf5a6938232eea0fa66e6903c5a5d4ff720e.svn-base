package com.smesh.main;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;

import org.json.JSONArray;
import org.json.JSONObject;

import com.samsung.android.example.helloaccessoryprovider.R;
import com.smesh.db.DBAdapter;
import com.smesh.dialog.InputID_Dialog;
import com.smesh.dialog.SOS_Dialog;
import com.smesh.helper.MyApplication;
import com.smesh.helper.SmeshPreference;
import com.smesh.main.AccessoryProviderService.LocalIBinder;
import com.smesh.network.BTClient;
import com.smesh.network.BTServer;
import com.smesh.network.CheckClient;
import com.smesh.network.CheckServer;
import com.smesh.network.SearchStruct;
import com.smesh.network.TimeTable;
import com.smesh.setting.Setting;
import com.smesh.timeline.TimeLineActivity;

import android.media.MediaPlayer;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTransaction;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.DialogInterface.OnDismissListener;
import android.database.Cursor;
import android.widget.Button;

public class MainActivity extends FragmentActivity implements
Fragment_Main.OnFragmentMainListener ,  TimeLineActivity.OnTimeLineCallback {
	
	private static final int ACTION_ENABLE_BT = 101;
	public static final String BLUE_NAME = "BluetoothEx";
	
	private static String USERId = "userId";
	private static String DATE = "saveDate";
	private static String TIME = "saveTime";
	private static String GPS = "gps";
	private static String MSG = "message";
	private static String MAC = "mac";
	private static String NOTCHECK = "N";
	private static String TIMETABLE_NUM = "timetable";
	public final static int FRAGMENT_ONE = 1;
	public final static int FRAGMENT_TWO = 2;
	public final static int FRAGMENT_THREE = 3;
	
	private Fragment_Main fragment_main;
	private static TimeLineActivity timelineActivity;
	private Setting settingActivity;
	private MediaPlayer mPlayer;
	private MyApplication myApp;
	private InputID_Dialog id_dialog;
	private SOS_Dialog sos_dialog;
	public SmeshPreference pref;
	public DBAdapter db;
	public static int isFregment =0;
	private final int UPDATE_TIME = 1000 * 60 * 60; // 1초가 60개면 1분인데 그게 60개니까
													// 10분
	private final int SERVER_CONNECT = 10;
	private final int CLIENT_CHECK = 20; // 클라이언트가 서버로 일단 연결되었고, 자신의 uuid를 날릴 준비가 되었다.
	private final int REAL_CHECK_CONNECT = 30; // 체크 커넥트가 성사되었다.
	private final int NEXT_CONNECT = 40;
	private final int SOCKET_FAILED = 50; // 소켓 연결 실패 
	private final int SERVER_ACCEPT_READY = 60;
	private final int SERVER_OKAY = 70;
	private final int SOS_CALL = 80;

	private ArrayList<BTServer> btServer;
	private ArrayList<BTClient> btClient;

	public int server_check_connect[], client_check_connect[];
	private SearchStruct temp_class[], search_class[];

	private Timer timer, update_timer;

	private TimeTable[] mTable = new TimeTable[600];

	private BluetoothAdapter mBA;
	private BluetoothDevice mDevice, checkDevice;

	private CheckServer checkServer = null;
	private CheckClient checkClient = null; 

	private int temp_cnt = 0;
	private int connect_idx = 0;
	private int current_eq, after_eq;
	private static int search_eq; // 검색된 장비
	private short rssi;
 
	private String my_mac, my_uuid;
	private String recv_client_uuid, recv_client_mac = null;
	
	private boolean first_connect = true; 
	private boolean is_register = false;
	private boolean is_tempclass_init = false;
	public static boolean is_minimum = false;
	
	private ArrayList<String> listServerMac, listClientMac;
	
	private BTServer mServer = null;
	private BTClient mClient = null;
	
	private int client_cnt = 0, server_cnt = 0; 
	
	private SosSendThread sos_thread;
	
	private JSONArray sendJsonArray;
	private JSONObject sendJsonObj;	
	
	
	private AccessoryProviderService m_accessoryService;
	private boolean m_bound = false; 
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		
		timelineActivity = new TimeLineActivity();
		myApp = (MyApplication) getApplication();
		 
		if (findViewById(R.id.main_fragment_view) != null) {
			if (savedInstanceState != null)
				return;

			fragment_main = new Fragment_Main();
			fragment_main.setArguments(getIntent().getExtras());
			FragmentTransaction trans = getSupportFragmentManager()
					.beginTransaction();
			trans.add(R.id.main_fragment_view, fragment_main).commit();
		} 
		
		btServer = new ArrayList<BTServer>();
		btClient = new ArrayList<BTClient>();
		listServerMac = new ArrayList<String>();
		listClientMac = new ArrayList<String>();
		 
		temp_class = new SearchStruct[30];
		server_check_connect = new int[7]; // 연결 소켓 확인
		client_check_connect = new int[7]; // 연결 소켓 확인
		
		MakeTable(); // 타임테이블 만들기 

		timer = new Timer();
		timer.schedule(time_task, 5000, 3000); // 5초 후에 3초 간격으로 실행

		update_timer = new Timer();
		timer.schedule(update_task, UPDATE_TIME, UPDATE_TIME); // 10분 마다 갱신하는거.

		mBA = BluetoothAdapter.getDefaultAdapter(); // 블루투스 어댑터를 구한다
 
		boolean isBlue = canUseBluetooth(); 
		if (isBlue) StartCheckServer(); 
		
		db = new DBAdapter(MainActivity.this); 
		db.open(); // db open 
		
		myApp.set_DB(db);
		pref = new SmeshPreference(this); 
		myApp.set_Pref(pref);
		String id = pref.getValue("USERId", " "); 
		if (id.equals(" ")) { // 처음에 메인에서 아이디 받아서 저장해야함
			id_dialog = new InputID_Dialog(MainActivity.this);
			id_dialog.setCancelable(false);
			id_dialog.show();
			pref.putValue("service", false);
		}
		String mac = pref.getValue("MAC", " "); // 맥주소 저장하기
		if (mac.equals(" ")) {
			WifiManager mng = (WifiManager) getSystemService(WIFI_SERVICE);
			WifiInfo info = mng.getConnectionInfo();
			pref.putValue("MAC", info.getMacAddress());
		} 
		
	}
	@Override
	protected void onStart() {
		// TODO Auto-generated method stub
		super.onStart();
		
		Intent intent = new Intent(this, AccessoryProviderService.class);
		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
	}


	@Override
	protected void onStop() {
		// TODO Auto-generated method stub
		super.onStop();
		if(m_bound)
		{
			unbindService(mConnection);
			m_bound=false;
		}
	}
		
	@Override
	protected void onPause() {
		if(mBA.isDiscovering())
			stopFindDevice();
		super.onPause();
	}

	@Override
	protected void onDestroy() {
		
		if(mBA.isDiscovering())
			stopFindDevice(); 
		super.onDestroy();
		
	}

	@Override
	protected void onResume() {
		
		if(!mBA.isDiscovering())
		{
			stopFindDevice();
			startFindDevice();
		} 
		super.onResume();
	}
	
	
	private ServiceConnection mConnection = new ServiceConnection() {
		
		@Override
		public void onServiceDisconnected(ComponentName name) {
			// TODO Auto-generated method stub
			//m_bound = false;
		}
		
		@Override
		public void onServiceConnected(ComponentName name, IBinder service) {
			// TODO Auto-generated method stub
			LocalIBinder binder = (LocalIBinder) service;
			m_accessoryService = binder.getService();
			//m_bound = true;
		}
	};

	private void StartCheckServer() {

		if(checkServer != null)
			checkServer = null; 
		checkServer = new CheckServer(mBA, mCheckServerHandler);
		checkServer.start();

		startFindDevice(); // 원격 디바이스 검색 시작
		setDiscoverable(); // 다른 디바이스에 자신을 노출
	}

	private void startFindDevice() {
		if(!is_register)
		{ 
			stopFindDevice();
			mBA.startDiscovery(); // 디바이스 검색 시작
			this.registerReceiver(mBlueRecv, new IntentFilter(BluetoothDevice.ACTION_FOUND)); // 원격 디바이스 검색 이벤트 리시버 등록
			is_register = true;
		}
	}

	private void stopFindDevice() {
		if (mBA.isDiscovering() && is_register) { // 현재 디바이스 검색 중이라면 취소한다
			mBA.cancelDiscovery();
			this.unregisterReceiver(mBlueRecv); // 브로드캐스트 리시버를 등록 해제한다
			is_register = false;
		}
	}

	private void setDiscoverable() { // 발견할 수 있게 함.
		if (mBA.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE)
			return; 
		Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
		intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 0);
		startActivity(intent);
	} 

	public boolean canUseBluetooth() {

		if (mBA == null) return false; // 블루투스 어댑터가 null 이면 블루투스 장비가 존재하지 않는다.
		if (mBA.isEnabled()) return true; // 블루투스 활성화 상태라면 함수 탈출

		Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); // 사용자에게 블루투스 활성화를 요청한다
		startActivityForResult(intent, ACTION_ENABLE_BT);
		return true;
	}
	
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		
		if( resultCode == RESULT_OK)
			StartCheckServer();
		else if( resultCode == RESULT_CANCELED) { }
		
		super.onActivityResult(requestCode, resultCode, data);
	}

	public void MakeTable() {
		for (int i = 0; i < 600; i++) {
			mTable[i] = new TimeTable();
		}

		myApp.set_TimeTable(mTable);  
	} 

	@Override
	public void onMainButtonClick(int position) {
		switch (position) {
		case FRAGMENT_ONE: // sos
			startSOS();
			isFregment =1;
			break;
		case FRAGMENT_TWO:// timeline
			changeFragment_timeline();
			isFregment =2;
			break;
		case FRAGMENT_THREE:// setting
			changeFragment_setting();
			isFregment =3;
			break;
		}
	} 
	
	public void startSOS() {
		mPlayer = mPlayer.create(getApplicationContext(), R.raw.warning); // 경고음 틀기위해서
		mPlayer.setLooping(true);
		mPlayer.start();
		// 지속적으로 sos 메세지를 주변에 날리거나 post 메세지를 날리는거 넣어야함
		myApp.sendPostMessage();
		myApp.getPostMessage();
		sos_dialog = new SOS_Dialog(MainActivity.this);
		
		sos_thread = new SosSendThread(mSosHandler, btClient.size(), btServer.size());
		Log.e("연결 client size : "+btClient.size(), "연결 server size : "+btServer.size());
		sos_thread.start();
		sos_dialog.show(); // 다이얼로그 보여줌
		
		sos_dialog.setOnDismissListener(new OnDismissListener() { // 다이얼로그가 꺼지면 호출되는 메소드.
			@Override
			public void onDismiss(DialogInterface dialog) {  
				new Thread(sos_thread).interrupt();
				mPlayer.stop();
				mPlayer.release();
			}
		});
	}

	public void changeFragment_timeline() {
		timelineActivity.setArguments(getIntent().getExtras());
		FragmentTransaction trans = getSupportFragmentManager()
				.beginTransaction();
		trans.replace(R.id.main_fragment_view, timelineActivity);
		trans.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
		trans.addToBackStack(null);
		trans.commit();
	}

	public void changeFragment_setting() {
		settingActivity = new Setting();
		settingActivity.setArguments(getIntent().getExtras());
		FragmentTransaction trans = getSupportFragmentManager()
				.beginTransaction();
		trans.replace(R.id.main_fragment_view, settingActivity);
		trans.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
		trans.addToBackStack(null);
		trans.commit();
	}


	public static int get_eq() {
		return search_eq;
	}

	public static void set_eq() {
		search_eq++;
	} 

	// 메소드가 다른 핸들러에서 재귀적으로 불리니까 다음 장비가 연결 안되는지는 걱정하지 말자.
	// 클라이언트로서 서버로 연결 시도하는 메소드
	public synchronized void Bluetooth_Connect() {
		mBA = BluetoothAdapter.getDefaultAdapter(); // 블루투스 어댑터를 구한다
		try {
			if (connect_idx < search_eq && search_class[connect_idx].get_address() != null) {
				checkDevice = mBA.getRemoteDevice(search_class[connect_idx].get_address());
				if(checkDevice != null)
				{
					if (search_class[connect_idx].get_address().equals(recv_client_mac) == false) {
						//Log.e("체크용 현재 연결 시도 장비 : ", "" + search_class[connect_idx].get_name());
						if(mBA.isDiscovering())
							stopFindDevice();
						checkClient = new CheckClient(checkDevice, mCheckClientHandler);
						checkClient.start();
					}
				}
			}
		} catch (Exception e) {
		}
	}
	
	public String make(Cursor cursor){
		sendJsonArray = new JSONArray();
		sendJsonObj = new JSONObject();
		int timetable_num = 0;
		String time[] = cursor.getString(cursor.getColumnIndex(TIME)).split(":");
		timetable_num = change_tablenum(time[1], time[2]);
		try {
			sendJsonObj.put(TIMETABLE_NUM, timetable_num);
			sendJsonObj.put(MAC, cursor.getString(cursor.getColumnIndex(MAC)));
			sendJsonObj.put(USERId, pref.getValue("USERId", "GUEST"));
			sendJsonObj.put(DATE, cursor.getString(cursor.getColumnIndex(DATE)));
			sendJsonObj.put(TIME,cursor.getString(cursor.getColumnIndex(TIME)));
			sendJsonObj.put(GPS,cursor.getString(cursor.getColumnIndex(GPS)));
			sendJsonObj.put(MSG, cursor.getString(cursor.getColumnIndex(MSG))); 
			sendJsonArray.put(sendJsonObj);
		} catch (Exception e) {
		}
			
		return sendJsonArray.toString();
	}
	
	public String get_make_string(Cursor cursor)
	{
		return cursor.getString(cursor.getColumnIndex(MSG));
	}

	public int change_tablenum(String M, String s) {
		int trans_time = 0;

		trans_time = (Integer.parseInt(M) % 10) * 60 + Integer.parseInt(s);

		return trans_time;
	}
	
	public String JSONparse(String jsonString) {

		if (jsonString == null)
			return " ";
		int receiveTableTime = 0;
		String receiveMac = null;
		String receiveId = null;
		String receiveDate = null;
		String receiveTime = null;
		String receiveGPS = null;
		String receiveMSG = null;

		try {
			JSONArray receiveJson = new JSONArray(jsonString);
			JSONObject receiveObj = receiveJson.getJSONObject(0);

			receiveTableTime = receiveObj.getInt(TIMETABLE_NUM);
			receiveMac = receiveObj.getString(MAC);
			receiveId = receiveObj.getString(USERId);
			receiveDate = receiveObj.getString(DATE);
			receiveTime = receiveObj.getString(TIME);
			receiveGPS = receiveObj.getString(GPS);
			receiveMSG = receiveObj.getString(MSG); 
			
//			Log.e("jsonpaser ", "  receiveTableTime : " + receiveTableTime + "  receiveMac : " + receiveMac
//					+ "  receiveId : " + receiveId + "  receiveDate : " + receiveDate + "  receiveTime : " + receiveTime 
//					 + "  receiveGPS : " + receiveGPS + "  receiveMSG : " + receiveMSG );
		} catch (Exception e) { 
		}

		if (!mTable[receiveTableTime].Check(receiveMac, receiveTime)) {
			String used ="T";
			 
			db.inset_msg(receiveMac, receiveId, receiveDate, receiveTime,
					receiveGPS, receiveMSG, used + NOTCHECK);
			
			if( isFregment == 2)
				timelineActivity.insertInfo(receiveMac, receiveId, receiveDate, receiveTime, receiveGPS, receiveMSG, used + NOTCHECK, true);
			
			//Send Gear Message
			m_accessoryService.sendMsg("ID: " + receiveId + "||" + "MSG: " +receiveMSG);
			
			return receiveMac; 
		}
		else
		{
			return " ";
		}
	} 
	
	public void Me_Send(byte[] buffer, int size, String _mac) { // 연결된 모두에게 전부 다 보냄
		String msg = new String(buffer,0,size); 
		All_Send(-1, -1, msg, _mac); 
	} 
	
	public void All_Send(int server_index, int client_index, String _msg, String _remac) {  
		 
		// 연결된 서버들로 전송한다.
		for( int i = 0; i < btServer.size(); i++ ) 
		{
			if( (i != server_index) && (server_check_connect[i] == 1) && (!checkServerMacList(_remac)) ) // 연결된 애들은 빼고( i != ), 연결되었다고 알려진 list in index만 (i)
			{
				BTServer mBtserver = btServer.get(i); 
				if(mBtserver != null)
					mBtserver.all_send(_msg); // 리스트에 들어있는 서버 모두 전송 
			} 
		} 
		
		// 연결된 클라이언트들로 전송한다.
		for( int i = 0 ; i < btClient.size(); i++ ) 
		{
			if( (i != client_index) && (client_check_connect[i] == 1) &&(!checkClientMacList(_remac)) )
			{
				BTClient mBtclient = btClient.get(i);	
				if(mBtclient != null)
					mBtclient.all_send(_msg);
			} 
		}
	} 
	
	public boolean checkServerMacList(String _mac) // 같은게 검색되면 true
	{
		for(int i = 0; i<listServerMac.size(); i++)
		{
			if(listServerMac.get(i).equals(_mac))
				return true;
			else 
				return false;
		} 
		return false;
	}
	
	public boolean checkClientMacList(String _mac)
	{
		for(int i = 0; i<listClientMac.size(); i++)
		{
			if(listClientMac.get(i).equals(_mac)) // 같은게 검색되면
				return true;
			else 
				return false;
		} 
		return false;
	}
	
	public String CreateBaseUUID() 
	{  // 고유 UUID 생성하기
		final TelephonyManager mTelephonyManager = (TelephonyManager) getBaseContext().getSystemService(Context.TELEPHONY_SERVICE); 
		
		final String tmDevice, tmSerial, androidID;
		tmDevice = "" + mTelephonyManager.getDeviceId();
		tmSerial = "" + mTelephonyManager.getSimSerialNumber();
		androidID = "" + android.provider.Settings.Secure.getString(getContentResolver(), android.provider.Settings.Secure.ANDROID_ID);
		
		UUID deviceUuid = new UUID(androidID.hashCode(), ( (long) tmDevice.hashCode() << 32) | tmSerial.hashCode() );
		String deviceId = deviceUuid.toString();
		
		return deviceId;
	}
	
	public String CreateClientMac()
	{
		String _my_mac = pref.getValue("MAC", " "); // 자기 맥 주소 가져 옴.
		return _my_mac;
	}

	TimerTask time_task = new TimerTask() {
		public void run() {
			
			if (first_connect == true) // 첫 x초 일 때는
			{
				if (search_eq == 0) // x초가 경과해도 장비가 아직 없으면
				{
					stopFindDevice();
					startFindDevice(); // 중간에 다시 들어올 수도 있기 때문에
				}
				else {
					search_class = new SearchStruct[search_eq]; // 갯수만큼 새로 만듦. 
					if(search_class != null && is_tempclass_init)
					{
						for (int i = 0; i < search_eq; i++) {
							if( (temp_class[i].get_name() != null) && (temp_class[i].get_address() != null) && (temp_class[i].get_rssi() != 0) ) {
								search_class[i] = new SearchStruct(temp_class[i].get_name(), temp_class[i].get_address(), temp_class[i].get_rssi());
							}
						}
						try {
							Arrays.sort(search_class); // 오름차순(음수 기준)으로 정렬 완료. 가장가까운 것이 0번 배열에 들어감.
							if (search_eq > 0 && connect_idx < search_eq)
								Bluetooth_Connect(); // 연결이 끝난 이후에는
							first_connect = false;
						}catch(Exception e) {}
					} 
					else
						return;
				}
				current_eq = get_eq();
			} else {
				after_eq = get_eq(); // 총 10초 뒤에

				if (current_eq != after_eq) // 장비가 다르면
				{
					search_class = new SearchStruct[search_eq]; // 갯수만큼 새로 만듦.

					// search 클래스는 다시 만들 되
					for (int i = 0; i < search_eq; i++)
						search_class[i] = new SearchStruct(temp_class[i].get_name(), temp_class[i].get_address(), temp_class[i].get_rssi());
					
					if (search_eq > 0 && connect_idx < search_eq)
						Bluetooth_Connect(); // 연결이 끝난 이후에는
				} else { // 장비가 같으면 다시 찾아주세요.
					if(mBA.isDiscovering()) {
						stopFindDevice();
						startFindDevice();
					}
				}
				current_eq = get_eq(); // 다시 시간 구하는 중
			}
		}
	}; 

	BroadcastReceiver mBlueRecv = new BroadcastReceiver() {
		public void onReceive(android.content.Context context,
				android.content.Intent intent) {
			mDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // 인텐트에서 디바이스 정보 추출

			if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED) // 이미 페어링 된 디바이스는 검색하면 안됨.
			{
				temp_cnt = search_eq;
				try {
					rssi = intent.getShortExtra(BluetoothDevice.EXTRA_RSSI, Short.MIN_VALUE);
					String this_address = mDevice.getAddress();
					temp_cnt++;
					boolean is_same = false;

					if (temp_cnt == 1) {
						temp_class[0] = new SearchStruct(mDevice.getName(), mDevice.getAddress(), rssi);
						is_tempclass_init = true;
						set_eq();
					} else if (temp_cnt >= 2) {
						for (int i = 0; i < temp_cnt - 1; i++) // 같은 장비가 검색되는 것을 걸러줌.
						{
							if (temp_class[i].get_address().equals(this_address)) {
								is_same = true;
								break;
							}
						}
						if (!is_same) {
							temp_class[temp_cnt - 1] = new SearchStruct(mDevice.getName(), mDevice.getAddress(), rssi);
							set_eq(); // 검색한 결과 리스트에 스트럭쳐에 없으면 증가시켜 줌
							is_same = false;
						}
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			} // end of if
		}
	};

	// Real Socket(n번 소켓) 연결이 성공하든, 실패하든 불러지는 핸들러
	Handler nextConnectHandler = new Handler() { // 0번 소켓이 연결이 실패하거나(다음꺼 하기 위해) n 번 소켓 연결이 성공하면 들어오는 핸들러(n+1꺼 하기 위해)
		public void handleMessage(Message msg) {
		
			int is_connect = msg.arg2;  
			if(is_connect == NEXT_CONNECT) // 클라이언트가 연결되었으면 서버의 맥 주소를 가져올 수 있다. 
			{ 
				if(checkClient != null)
				{
					Log.e("체크 클라이언트", "캔슬");
					checkClient.cancel();
					checkClient = null;
				}
				
				if(mClient != null) 
					btClient.add(mClient);
				
				int _idx = msg.what;
				client_check_connect[_idx] = 1;
				
				myApp.increase_eq();
				fragment_main.set_client(++client_cnt);
				add_serverMacList(search_class[connect_idx].get_address()); // 현재 커넥트 된 인덱스의 장비의 주소를 클라이언트가 관리하는 서버의 맥 주소 목록으로 넣어준다. 
			}  
			 
			connect_idx++; // ( 소켓 연결에 실패하거나 성공해도 다음꺼 연결하기 위해)

			if (checkClient != null) // 클라이언트가 안 만들어지면 종료할 필요 없음.
				checkClient = null;

			// 연결 장비 < 검색 장비
			if (connect_idx < search_eq) {
				Bluetooth_Connect(); // 연결이 끝난 이후에는
			} 
		}
	};
	
	Handler mCheckServerHandler = new Handler() {
		public void handleMessage(Message msg) {
			int check = msg.what;
			if (check == REAL_CHECK_CONNECT) {  
				String client_uuidmac = msg.obj.toString();  
				recv_client_uuid = client_uuidmac.substring(0, 36);
				recv_client_mac = client_uuidmac.substring(36);
				fragment_main.set_recvmac(recv_client_mac);
				mServer = new BTServer(mBA, btServer.size(), mServerHandler, recv_client_uuid, recv_client_mac); 
				mServer.start(); // 0-n 소켓 연결 
				checkServer.ServerReady(); // 서버가 준비되었다고 알림  
			} 
		}
	};

	// 체크 소켓이 연결되거나 실패하면 불러지는 핸들러
	Handler mCheckClientHandler = new Handler() { 
		public void handleMessage(Message msg) {
			int check = msg.what;

			if (check == CLIENT_CHECK) { // 체크용 클라이언트가 연결 되었으면 
				
				my_uuid = CreateBaseUUID(); // 내 UUID를 받는다. 
				my_mac = CreateClientMac(); // 내 맥 주소를 받는다. 
				fragment_main.set_mymac(my_mac);
				checkClient.UuidMacSend(my_uuid, my_mac);
				
			} else if(check == SERVER_OKAY)  {
				try {  
					Log.e("Client 연결 ", "시도");
					mClient = new BTClient(checkDevice, mClientHandler, btClient.size(), my_uuid, my_mac, nextConnectHandler);  
					mClient.start(); // 클라이언트를 붙여야지 

				} catch (Exception e) {
					e.printStackTrace();
					Log.e("체크 Client 연결 ", "실패");
				}
			} else if (check == SOCKET_FAILED) {
				connect_idx++; // ( 소켓 연결에 실패해도 다음꺼 연결하기 위해)

				if (checkClient != null) // 클라이언트가 안 만들어지면 종료할 필요 없음.
					checkClient = null;

				// 연결 장비 < 검색 장비
				if (connect_idx < search_eq) {
					Bluetooth_Connect(); // 연결이 끝난 이후에는
				}
			}
			
			//startFindDevice();
		}
	};


	Handler mServerHandler = new Handler() { // 서버에서는 받은 애 빼고, 모든 클라이언트에게 전송
		public void handleMessage(Message msg) {
			
			int idx = msg.what;   
			
			if (idx == SERVER_CONNECT) // 서버는 연결 되었다고 알려졌으면
			{ 
				if(mServer != null)
					btServer.add(mServer);
				
				myApp.increase_eq();
				fragment_main.set_server(++server_cnt);
				add_clientMacList(msg.obj.toString()); // 서버에서는 클라이언트의 Mac주소 넣어야 함. 
				
				int _idx = msg.arg1; // 연결된 애는 1로
				server_check_connect[_idx] = 1; // 서버에서 연결된 애들 인덱스 관리 
				
				// 또 체크 서버 객체를 만들어서 입력을 대기해야 한다.
				mBA = BluetoothAdapter.getDefaultAdapter();
				
				if(checkServer != null) {
					Log.e("체크 서버", "캔슬");
					checkServer.cancel();
					checkServer = null;
				}
				
				checkServer = new CheckServer(mBA, mCheckServerHandler);
				checkServer.start(); 
			} 
			else // 서버가 연결된 상태가 아니고 수신 상태의 구문 (서버에서 수신받은 메시지를 모든 애들한테 전송하기 위해서 -1을 넣어줌)
			{
				String message = msg.obj.toString();
				Log.e("핸들러가 받은 서버 수신 메시지", ""+message);
				if(message != null)
				{
					String recv_mac = JSONparse(message); // 보낸 사람의 맥 주소가 반환됨.
					if(!recv_mac.equals(" "))  //true 안받았던거
						All_Send(idx, -1, message, recv_mac); // 1 : server_index, 2 :// client_index 
				}
			}
		}
	};
	
	Handler mSosHandler = new Handler() {
		public void handleMessage(Message msg) {
			int what = msg.what;
			
			if(what == SOS_CALL)
			{
				Log.e("SOS CALL", "불러졌어");
				Cursor cursor = db.getPostMessage();
				int count = cursor.getCount();
				for(int i=0; i<count ; i++){
					String send = make(cursor); 
					All_Send(-1, -1, send, "MAC"); 	
					cursor.moveToNext();
				}
			}
		}
	};

	Handler mClientHandler = new Handler() { // 클라이언트에서는 모든 server와 받은 애 빼고 보낸다.
		public void handleMessage(Message msg) {
			int idx = msg.what; 
			String message = msg.obj.toString(); 
			Log.e("핸들러가 받은 클라이언트 수신 메시지", ""+message);
			if(message != null)
			{
				String recv_mac = JSONparse(message); // 맥 주소를 반환.
				if(!recv_mac.equals(" "))
				All_Send(-1, idx, message, recv_mac); 
			}
		}
	};
	
	TimerTask update_task = new TimerTask() {
		public void run() {
			if (mTable != null)
				mTable = null;

			MakeTable();
		}
	};
	
	public ArrayList<String> get_serverMacList()
	{
		return listServerMac;
	}
	
	public void add_serverMacList(String _mac)
	{ 
		listServerMac.add(_mac);
	}  
	
	public ArrayList<String> get_clientMacList()
	{
		return listClientMac;
	}
	
	public void add_clientMacList(String _mac)
	{ 
		listClientMac.add(_mac);
	}
	
	@Override
	public void onSendMessage(byte[] buffer, int size, String _mac) {
		Me_Send(buffer, size, _mac); 
	} 
	
	
}

